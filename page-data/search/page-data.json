{"componentChunkName":"component---src-pages-search-jsx","path":"/search/","result":{"data":{"allMarkdownRemark":{"nodes":[{"excerpt":"JPA를 사용해 객체 간 관계를 설정하는 부분을 구현하다가 객체 변경 시 save() 메서드를 호출해야 하는지에 대한 의문이 들었습니다. 결론부터 말하자면 호출하지 않아도 됩니다. 이게 다 영속성 컨텍스트의 변경 감지(dirty checking) 특성 덕분입니다. 이번 글에서는 이러한 영속성 컨텍스트의 장점들을 알아보겠습니다. 영속성 컨텍스트란? 영속성 …","fields":{"slug":"/jpa1/"},"frontmatter":{"date":"October 04, 2024","title":"JPA에서 객체 변경 시 save() 호출이 필요할까? - 영속성 컨텍스트의 힘","tags":["JPA","Persistence context"]},"rawMarkdownBody":"JPA를 사용해 객체 간 관계를 설정하는 부분을 구현하다가 **객체 변경 시 save() 메서드를 호출해야 하는지**에 대한 의문이 들었습니다. 결론부터 말하자면 **호출하지 않아도 됩니다.**\r\n\r\n이게 다 영속성 컨텍스트의 **변경 감지(dirty checking)** 특성 덕분입니다. 이번 글에서는 이러한 영속성 컨텍스트의 장점들을 알아보겠습니다.\r\n\r\n## 영속성 컨텍스트란?\r\n영속성 컨텍스트는 엔티티를 영구적으로 저장하는 논리적인 환경입니다. 쉽게 말해, 애플리케이션과 DB 사이의 중간 계층 역할을 하죠. 엔티티 매니저(Entity Manager)가 영속성 컨텍스트를 관리하며, 이를 통해 엔티티 상태를 추적하고 관리합니다.\r\n\r\n일반적으로 EntityManager.persist() 메서드를 호출하면 객체가 DB에 저장된다고 생각할 수 있지만, 실제로는 영속성 컨텍스트에서 관리되기 시작한 것입니다. 실제 DB에 쿼리가 날아가는 시점은 트랜잭션이 커밋될 때입니다.\r\n\r\n\r\n## 영속성 컨텍스트의 주요 특성\r\n\r\n영속성 컨텍스트의 주요 특성 몇 가지를 알아보겠습니다.\r\n\r\n### 변경 감지 (Dirty Checking)\r\n앞에서 말했던 변경 감지입니다. JPA의 핵심 기능 중 하나인 변경 감지는 영속성 컨텍스트가 관리하는 엔티티의 변경사항을 자동으로 감지합니다. 트랜잭션 커밋 시점에 JPA는 영속성 컨텍스트에 있는 엔티티와 **스냅샷(최초 영속 상태의 엔티티 상태)**을 비교하여 변경된 부분이 있으면 업데이트 쿼리를 쓰기 지연 sql 저장소에 넣고, DB에 반영하고 커밋합니다. **이를 통해 객체의 변경 사항을 별도로 save() 호출 없이도 처리할 수 있습니다.**\r\n![](./image-1.png)\r\n\r\n### 1차 캐시\r\n영속성 컨텍스트는 1차 캐시를 가지고 있습니다. 엔티티를 영속화하면 DB에 바로 저장되는 것이 아니라, 먼저 1차 캐시에 저장됩니다. 이후 같은 엔티티를 조회할 때는 DB가 아닌 캐시에서 바로 조회하게 되어 성능을 높일 수 있습니다.\r\n![](./image-2.png)\r\n\r\n### 동일성 보장\r\n영속성 컨텍스트는 동일성을 보장합니다. 동일한 트랜잭션 내에서 같은 엔티티를 조회하면, == 비교로도 동일한 객체임을 확인할 수 있습니다. 즉, 동일한 엔티티는 트랜잭션 내에서 같은 인스턴스로 관리됩니다.\r\n![](./image-3.png)\r\n\r\n### 트랜잭션을 지원하는 쓰기 지연\r\n엔티티를 여러 번 저장할 때마다 DB에 쿼리가 바로 실행되지 않습니다. 영속성 컨텍스트에 저장된 SQL 쿼리들은 쓰기 지연 SQL 저장소에 모아두고, 트랜잭션 커밋 시 한꺼번에 DB로 전송됩니다. 이 덕분에 성능이 향상됩니다.\r\n![](./image-4.png)\r\n![](./image-5.png)\r\n![](./image-6.png)\r\n## 영속성 컨텍스트의 상태 DB와 동기화 하기 - 플러시(Flush)\r\n\r\n플러시(Flush)는 영속성 컨텍스트의 상태를 DB와 동기화하는 작업입니다.\r\n\r\n### 플러시가 발생할 때\r\n\r\n이때 플러시가 발생하면 다음과 같은 작업들이 이루어집니다.\r\n\r\n**1. 변경 감지 (Dirty Checking)** : 영속성 컨텍스트에 저장된 엔티티들이 변경되었는지 확인합니다.\r\n\r\n**2. 수정된 엔티티를 쓰기 지연 SQL 저장소에 등록** : 변경된 엔티티가 있으면 그에 해당하는 UPDATE 쿼리를 생성하여 쓰기 지연 SQL 저장소에 등록합니다.\r\n\r\n**3. 쓰기 지연 SQL 저장소의 쿼리를 DB에 전송** : 플러시 시점에 쓰기 지연 SQL 저장소에 저장된 등록, 수정, 삭제 쿼리들을 데이터베이스로 전송해 실제로 DB에 반영합니다.\r\n\r\n### 플러시를 발생시키는 방법\r\n\r\n**1. em.flush() 호출** : 영속성 컨텍스트를 수동으로 플러시하고 싶을 때 직접 호출할 수 있습니다.\r\n\r\n**2. 트랜잭션 커밋** : 트랜잭션이 커밋되는 시점에 JPA가 자동으로 플러시를 실행합니다. 이때 변경 사항들이 DB에 반영됩니다.\r\n\r\n**3. JPQL 쿼리 실행** : JPQL을 실행할 때도 자동으로 플러시가 호출됩니다. 이는 JPQL로 조회할 때, 영속성 컨텍스트에 있는 최신 상태의 엔티티가 반영되어야 하기 때문입니다. 예를 들어, em.persist()로 엔티티를 영속성 컨텍스트에 등록한 후, JPQL을 실행하면 DB에 반영된 상태에서 조회를 해야 하므로 플러시가 발생합니다.\r\n\r\n### 플러시의 특징\r\n\r\n**1. 영속성 컨텍스트를 비우지 않음** : 플러시는 단순히 변경 내용을 DB에 동기화할 뿐, 영속성 컨텍스트 자체를 비우지는 않습니다. 즉, 플러시 이후에도 영속성 컨텍스트는 유지됩니다.\r\n\r\n**2. 트랜잭션과의 관계** : 트랜잭션의 작업 단위가 중요하며, DB와의 동기화는 보통 커밋 직전에만 일어나면 충분합니다. 이는 트랜잭션의 일관성을 유지하기 위해 중요한 메커니즘입니다.\r\n\r\n## 그렇다면 ID로 다시 조회해야 할까?\r\n영속성 컨텍스트는 트랜잭션 내에서 동일한 엔티티의 동일성을 보장하지만, 트랜잭션 범위 밖에서는 보장되지 않기 때문에 ID로 다시 조회해야 합니다. 트랜잭션이 종료되면 영속성 컨텍스트는 더 이상 엔티티를 관리하지 않기 때문에 새로운 트랜잭션 내에서 엔티티를 조회할 필요가 있습니다.\r\n\r\n## 마치며\r\n저랑 비슷한 궁금증이 있으셨던 분들이 이 글을 통해 도움이 되셨으면 좋겠습니다. 읽어주셔서 감사드리고, 잘못된 부분이 있으면 댓글 남겨주세요.\r\n\r\nreference : https://www.inflearn.com/course/lecture?courseSlug=ORM-JPA-Basic"},{"excerpt":"이 글은 구름톤 유니브에서 들은 강의를 정리한 내용입니다. 이미지를 업로드하고, opencv를 사용하여 이미지에서 얼굴을 탐지하는 웹 서비스를 만들어보겠습니다. 이미지 DB에 저장하기 이미지 업로드 기능을 처리할 수 있는 모델을 정의한 코드입니다. 이 모델은 사용자가 업로드한 이미지 파일과 그에 대한 메타데이터(설명, 업로드된 시간)를 관리합니다. Dja…","fields":{"slug":"/groomthon_study/"},"frontmatter":{"date":"October 03, 2024","title":"예측모델 기반 face detection 웹서비스 구현","tags":["opencv","django"]},"rawMarkdownBody":"이 글은 구름톤 유니브에서 들은 강의를 정리한 내용입니다. 이미지를 업로드하고, opencv를 사용하여 이미지에서 얼굴을 탐지하는 웹 서비스를 만들어보겠습니다.\r\n\r\n## 이미지 DB에 저장하기\r\n이미지 업로드 기능을 처리할 수 있는 모델을 정의한 코드입니다. 이 모델은 사용자가 업로드한 이미지 파일과 그에 대한 메타데이터(설명, 업로드된 시간)를 관리합니다. Django의 ORM을 통해 데이터베이스에 매핑되며, 이를 사용해 이미지와 관련된 데이터를 저장하고 관리할 수 있습니다. 코드의 각 부분을 자세히 설명해보겠습니다.\r\n```python\r\nclass ImageUploadModel(models.Model):\r\n    description = models.CharField(max_length=255, blank=True)\r\n    document = models.ImageField(upload_to='images/%Y/%m/%d')\r\n    uploaded_at = models.DateTimeField(auto_now_add=True)\r\n\r\n```\r\n### description 필드\r\n이 필드는 업로드된 이미지에 대한 설명을 저장하는 텍스트 필드입니다. 이 필드의 최대 길이는 255자로 제한합니다. 폼에서 이 필드를 빈 채로 제출하는 것을 허용하여 사용자가 설명을 생략해도 오류가 발생하지 않으며, is_valid() 함수에서 유효한 데이터로 간주됩니다.\r\n\r\n### document 필드\r\n실제 이미지 파일을 저장하는 필드입니다. Django의 이미지 전용 필드로, 이미지 업로드를 다룰 때 사용합니다. 파일이 저장될 경로를 지정합니다. 여기서 %Y, %m, %d는 각각 업로드 시점의 연도, 월, 일을 나타냅니다. 예를 들어, 2024년 10월 3일에 업로드된 파일은 /images/2024/10/03/ 폴더 아래에 저장됩니다.\r\n\r\n### uploaded_at 필드\r\n파일이 업로드된 시간을 저장하는 필드입니다. 객체가 처음 생성될 때 현재 날짜와 시간이 자동으로 저장됩니다. 이후에는 수정되지 않습니다.\r\n\r\n## 폼으로 사용자에게 받은 데이터 처리하기\r\n이 코드는 Django의 폼을 정의한 것으로, 사용자로부터 데이터를 입력받아 처리하는 방식입니다. 여기서는 두 가지 폼을 다룹니다: SimpleUploadForm과 ImageUploadForm. 각각의 폼이 어떤 역할을 하는지 살펴보겠습니다.\r\n\r\n### SimpleUploadForm\r\n```python\r\nclass SimpleUploadForm(forms.Form):\r\n    title = forms.CharField(max_length=50)\r\n    image = forms.ImageField()\r\n\r\n```\r\n- **SimpleUploadForm**은 forms.Form 클래스를 상속받아 직접 정의한 폼입니다. 이 폼은 이미지를 업로드하는 가장 기본적인 기능을 구현합니다.\r\n\r\n**필드 설명**\r\n\r\n- title = forms.CharField(max_length=50): 최대 50자까지 입력 가능한 텍스트 필드입니다. 사용자가 업로드한 이미지의 제목을 입력할 수 있습니다.\r\n- image = forms.ImageField(): 이미지를 업로드할 수 있는 필드입니다. ImageField는 FileField를 상속받아, 이미지 파일인지 확인하는 추가 유효성 검사를 합니다.\r\n\r\n이 폼은 간단한 이미지 업로드와 제목 입력 기능을 제공하는데, 폼 필드가 고정되어 있어 어떤 모델에도 종속되지 않습니다. 따라서 데이터를 모델에 직접 연결하지 않는 경우에 주로 사용됩니다.\r\n\r\n### ImageUploadForm\r\n```python\r\nclass ImageUploadForm(forms.ModelForm):\r\n    class Meta:\r\n        model = ImageUploadModel\r\n        fields = ('description', 'document', )\r\n\r\n```\r\n- **ImageUploadForm**은 forms.ModelForm을 상속받아 모델과 연결된 폼을 생성합니다. 이 폼은 데이터베이스 모델인 ImageUploadModel과 직접 연결되어 있어, 사용자가 입력한 데이터가 바로 모델의 필드에 매핑됩니다.\r\n\r\n**메타 데이터**\r\n\r\n- model = ImageUploadModel: 이 폼이 연결된 모델을 명시합니다. ImageUploadModel은 업로드된 이미지와 설명을 저장하는 모델입니다.\r\n- fields = ('description', 'document', ): 사용자가 입력할 수 있는 필드 목록입니다. description과 document만을 입력받고, uploaded_at 필드는 자동으로 설정되므로 입력받지 않습니다.\r\n\r\n## 이미지에 Face detection 적용하기\r\n\r\n아래 코드를 통해 본격적으로 이미지에서 얼굴과 눈을 탐지하게 됩니다. OpenCV에서 제공하는 Haar Cascade Classifier를 사용하여 구현하게 됩니다. 코드를 자세히 알아보겠습니다.\r\n\r\n### 기본적인 이미지 처리\r\n먼저, 이미지를 받아와서 얼굴과 눈을 탐지하는 과정이 필요하겠죠? 이를 위해 이미지 파일을 cv2.imread()를 사용해 읽어옵니다. OpenCV는 이미지를 NumPy 배열 형태로 다루기 때문에, 이미지가 정상적으로 로드됐는지 확인하는 것이 중요합니다.\r\n\r\n```python\r\nimg = cv2.imread(path, 1)\r\nif type(img) is np.ndarray:\r\n    print(img.shape)\r\n\r\n```\r\n위 코드에서는 이미지를 성공적으로 로드했을 때, 그 이미지의 크기(가로, 세로, 채널)를 출력합니다. 이제 이미지가 너무 클 경우를 대비해 크기를 조정하는 과정을 추가해 보겠습니다.\r\n\r\n### 이미지 크기 조정\r\n이미지의 가로가 640px보다 크거나, 세로가 480px보다 크면 크기를 축소해줍니다. 이렇게 하면 너무 큰 이미지로 인해 처리 속도가 느려지는 것을 방지할 수 있습니다.\r\n\r\n```python\r\nresize_needed = False\r\nif img.shape[1] > 640: \r\n    resize_needed = True\r\n    new_w = img.shape[1] * (640.0 / img.shape[1])\r\n    new_h = img.shape[0] * (640.0 / img.shape[1])\r\nelif img.shape[0] > 480:\r\n    resize_needed = True\r\n    new_w = img.shape[1] * (480.0 / img.shape[0])\r\n    new_h = img.shape[0] * (480.0 / img.shape[0])\r\n\r\nif resize_needed:\r\n    img = cv2.resize(img, (int(new_w), int(new_h)))\r\n\r\n\r\n```\r\n여기서 resize_needed 플래그를 사용해 이미지 크기 조정이 필요한 경우에만 리사이즈를 진행합니다. 가로 또는 세로가 기준보다 크면, 해당 비율에 맞게 크기를 줄입니다.\r\n\r\n### 얼굴과 눈 탐지\r\n\r\n이제 본격적으로 얼굴과 눈을 탐지해볼 차례입니다. OpenCV에서 제공하는 Haar Cascade Classifier를 사용해 얼굴과 눈을 탐지할 수 있는데요, 미리 학습된 모델을 활용하여 빠르게 얼굴과 눈을 찾을 수 있습니다.\r\n\r\n```python\r\nface_cascade = cv2.CascadeClassifier(baseUrl + 'haarcascade_frontalface_default.xml')\r\neye_cascade = cv2.CascadeClassifier(baseUrl + 'haarcascade_eye.xml')\r\ngray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)\r\nfaces = face_cascade.detectMultiScale(gray, 1.3, 5)\r\n```\r\n먼저, 이미지를 그레이스케일로 변환한 후 얼굴을 탐지합니다. 여기서 detectMultiScale() 함수는 얼굴을 찾기 위한 주요 함수입니다. 탐지된 얼굴의 좌표를 바탕으로 사각형을 그려주는 작업도 같이 진행합니다.\r\n```python\r\nfor (x, y, w, h) in faces:\r\n    cv2.rectangle(img, (x, y), (x+w, y+h), (255, 0, 0), 2)\r\n    roi_gray = gray[y:y+h, x:x+w]\r\n    roi_color = img[y:y+h, x:x+w]\r\n    eyes = eye_cascade.detectMultiScale(roi_gray)\r\n    for (ex, ey, ew, eh) in eyes:\r\n        cv2.rectangle(roi_color, (ex, ey), (ex+ew, ey+eh), (0, 255, 0), 2)\r\n\r\n```\r\n얼굴을 찾은 후에는 그 영역을 기반으로 다시 눈을 탐지합니다. 얼굴 영역 내에서 눈을 찾고, 해당 부분에도 사각형을 그려줍니다. 얼굴은 파란색 사각형으로, 눈은 녹색 사각형으로 표시됩니다.\r\n\r\n### 결과 이미지 저장\r\n얼굴과 눈을 찾았으면 이제 그 결과를 이미지 파일로 저장해야겠죠? 이를 위해 cv2.imwrite() 함수를 사용해 원본 파일 경로에 덮어쓰거나, 새로운 파일을 생성해 저장할 수 있습니다.\r\n```python\r\ncv2.imwrite(path, img)\r\n\r\n```\r\n이렇게 하면 얼굴과 눈이 탐지된 이미지가 저장됩니다.\r\n\r\n## 화면 구성\r\n먼저 화면을 구성하는 코드를 알아보겠습니다. 간단히 **이미지를 간단히 업로드하는 기능, 얼굴 탐지 기능**으로 나눠져 있는데요. 아래에서 더 자세히 알아보겠습니다.\r\n### 간단한 이미지 업로드\r\n다음은 이미지를 간단히 업로드하는 기능입니다. 이 뷰는 GET 요청일 때는 빈 폼을 보여주고, POST 요청일 때는 사용자가 업로드한 이미지를 처리합니다.\r\n\r\n![](./image-1.png)\r\n\r\n```python\r\ndef simple_upload(request):\r\n  if request.method == 'POST':\r\n    form = SimpleUploadForm(request.POST, request.FILES)\r\n    if form.is_valid():\r\n        myfile = request.FILES['image']\r\n        fs = FileSystemStorage()\r\n        filename = fs.save(myfile.name, myfile)\r\n        uploaded_file_url = fs.url(filename)\r\n        context = {'form': form, 'uploaded_file_url': uploaded_file_url}\r\n        return render(request, 'opencv_webapp/simple_upload.html', context)\r\n  else:\r\n    form = SimpleUploadForm()\r\n    context = {'form': form}\r\n    return render(request, 'opencv_webapp/simple_upload.html', context)\r\n```\r\n### 얼굴 탐지 기능\r\n\r\n얼굴 탐지는 업로드한 이미지에서 얼굴을 찾아주는 기능입니다. 여기서는 사용자가 이미지를 업로드한 후, 그 이미지를 분석해 얼굴을 탐지하는 과정을 구현합니다.\r\n![](./image-2.png)\r\n\r\n```python\r\ndef detect_face(request):\r\n    if request.method == 'POST':\r\n        form = ImageUploadForm(request.POST, request.FILES)\r\n\r\n        if form.is_valid():\r\n            post = form.save(commit=False)\r\n            post.save()\r\n            imageURL = settings.MEDIA_URL + form.instance.document.name\r\n            cv_detect_face(settings.MEDIA_ROOT_URL + imageURL)\r\n            return render(request, 'opencv_webapp/detect_face.html', {'form':form, 'post':post})\r\n    else:\r\n        form = ImageUploadForm()\r\n        return render(request, 'opencv_webapp/detect_face.html', {'form':form})\r\n\r\n```\r\n- **POST 요청**: 사용자가 이미지를 업로드하고 나면 ImageUploadForm을 통해 데이터를 검증합니다. 유효한 데이터라면, 이미지 파일을 DB에 저장하고 파일 경로를 얻어온 후, 미리 만들어둔 얼굴 탐지 함수 cv_detect_face()를 호출합니다. 이 함수는 이미지에서 얼굴을 감지하고, 그 결과를 이미지에 반영하는 역할을 합니다.\r\n\r\n- **GET 요청**: 이 경우는 사용자가 처음 접근할 때 빈 폼을 보여줍니다."},{"excerpt":"지난 글에서는 Google Cloud Platform 인스턴스에 Jenkins 컨테이너를 실행시켰습니다. 이번 글에서는 Jenkins를 세팅하고, 파이프라인을 구성하여 본격적으로 프로젝트를 배포하고 CI/CD를 자동화해보겠습니다. Jenkins 세팅 Jenkins 방화벽 규칙 설정 Jenkins는 기본적으로 8080 포트를 사용하여 웹 인터페이스를 제공합…","fields":{"slug":"/deploy2/"},"frontmatter":{"date":"October 01, 2024","title":"Jenkins 사용해 CI/CD 파이프라인 자동화하기","tags":["CI/CD","Jenkins"]},"rawMarkdownBody":"지난 글에서는 Google Cloud Platform 인스턴스에 Jenkins 컨테이너를 실행시켰습니다. 이번 글에서는 Jenkins를 세팅하고, 파이프라인을 구성하여 본격적으로 프로젝트를 배포하고 CI/CD를 자동화해보겠습니다.\r\n\r\n## Jenkins 세팅\r\n\r\n### Jenkins 방화벽 규칙 설정\r\n\r\nJenkins는 기본적으로 8080 포트를 사용하여 웹 인터페이스를 제공합니다. GCP 인스턴스에서 이 포트에 접근할 수 있도록 방화벽 규칙을 설정해야 합니다.\r\n\r\nGCP 콘솔에 접속하고, 네트워크 서비스 -> VPC 네트워크 -> 방화벽 규칙으로 이동한 후, '방화벽 규칙 만들기'를 클릭하고, 다음과 같이 설정합니다.\r\n\r\n![](./image-1.png)\r\n![](./image-2.png)\r\n\r\n### Jenkins 초기 설정\r\n\r\n아래 명령어로 초기 관리자 비밀번호를 확인합니다.\r\n```bash\r\nsudo cat /var/lib/jenkins/secrets/initialAdminPassword\r\n```\r\n[GCP public ip]:8080 으로 Jenkins에 접속하여 초기 관리자 비밀번호를 입력합니다.\r\n\r\n![](./image-3.png)\r\n\r\n추천 플러그인을 설치하여 Jenkins 설정을 완료합니다.\r\n\r\n![](./image-4.png)\r\n\r\n## 파이프라인 구성하기\r\n\r\n이제 Jenkins에서 새로운 Item을 누르고, 파이프라인을 구성해보겠습니다. 저번 글에서 배포과정을 3단계로 나눴던 것처럼 **파이프라인도 git clone, build, docker build & run으로 구성**해보도록 하겠습니다.\r\n\r\n![](./image-5.png)\r\n```bash\r\npipeline {\r\n    agent any\r\n    stages {\r\n        stage('Github') {\r\n            steps {\r\n                git branch: 'develop', url: 'https://github.com/where-wear/where-wear-backend.git'\r\n            }\r\n        }\r\n        stage('Build') {\r\n            steps {\r\n                sh 'chmod +x gradlew'\r\n                sh \"./gradlew bootJar --debug\"\r\n            }\r\n        }\r\n        stage('Docker Build & Run') {\r\n            steps {\r\n                script {\r\n                    // Docker 이미지 이름 설정\r\n                    def imageName = \"wherewear-backend:latest\"\r\n                    \r\n                    // Docker 이미지를 빌드\r\n                    sh \"docker build -t ${imageName} .\"\r\n                    \r\n                    // 기존 컨테이너 중지하고 제거\r\n                    sh \"docker stop wherewear-backend\"\r\n                    sh \"docker rm wherewear-backend\"\r\n                    \r\n                    // Docker 컨테이너를 새로 실행\r\n                    sh \"docker run -d --name wherewear-backend -p 8081:8080 ${imageName}\"\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n```\r\n"},{"excerpt":"이번 글에서는 Docker와 Jenkins를 사용해 배포한 과정에 대해서 이야기해보려고 합니다.  Jenkins 없이 배포했다면 어땠을까? 일단 주요 배포과정을 단순하게 아래 3단계로 나누어 생각해 보겠습니다. 먼저 GCP 인스턴스에서 프로젝트 github repository를 clone 하여야 합니다. 다음으로는 프로젝트를 빌드해야 합니다. 프로젝트 빌…","fields":{"slug":"/deploy/"},"frontmatter":{"date":"September 28, 2024","title":"Google Cloud Platform에서 Jenkins 도커 컨테이너 실행하기","tags":["CI/CD","docker","Jenkins"]},"rawMarkdownBody":"이번 글에서는 Docker와 Jenkins를 사용해 배포한 과정에 대해서 이야기해보려고 합니다. \r\n\r\n## Jenkins 없이 배포했다면 어땠을까?\r\n일단 주요 배포과정을 단순하게 아래 3단계로 나누어 생각해 보겠습니다.\r\n\r\n먼저 GCP 인스턴스에서 **프로젝트 github repository를 clone** 하여야 합니다.\r\n```bash\r\ngit clone https://github.com/where-wear/where-wear-backend.git\r\n```\r\n다음으로는 **프로젝트를 빌드**해야 합니다. 프로젝트 빌드는 Gradle Wrapper로 할 수 있습니다. Gradle Wrapper를 실행하는 명령어인 gradlew에 실행 권한을 부여하고, 빌드 합니다.\r\n```bash\r\nchmod +x gradlew\r\n./gradlew bootJar --debug\r\n```\r\n그러면 Java 애플리케이션, 라이브러리 및 관련 리소스가 압축된 **JAR파일이 생성**됩니다. 이 JAR파일을 실행하여 **애플리케이션을 실행**시킵니다.\r\n```bash\r\njava -jar wherewear-0.0.1-SNAPSHOT.jar\r\n```\r\n성공적으로 배포가 완료 되었습니다. 하지만, 이후에 프로젝트 코드가 수정되고 메인 브랜치에 병합된다면, 위 과정을 또 반복해야 할겁니다. 이런 **수고스러운 과정을 없애기 위해서 Jenkins를 사용하여 CI(지속적 통합)/CD(지속적 배포) 과정을 자동화** 해보겠습니다.\r\n\r\n## Jenkins를 사용한 CI/CD 자동화\r\n이제 CI/CD 과정을 자동화 해보겠습니다. 먼저 GCP 인스턴스에 **Jenkins를 설치**해야 합니다. Jenkins는 스프링부트 애플리케이션과 격리된 환경에서 실행하기 위해서 GCP 인스턴스에 Jenkins를 직접 설치하지 않고, **Jenkins 도커 컨테이너를 만드는 방법**을 사용하겠습니다. 그러면 결국 **GCP 인스턴스에는 Jenkins 컨테이너와 애플리케이션 컨테이너 두 대가 띄워지게 됩니다.**\r\n\r\n생각해봐야 할 부분이 있습니다. Jenkins가 프로젝트를 빌드하고 애플리케이션 컨테이너를 띄우게 되는데, 그러면 Jenkins가 Docker를 사용하려면 Jenkins 안에 Docker를 설치해야 할까요? 하지만 이 방법(Docker-in-Docker)을 사용한다면 컨테이너 내에서 루트 권한으로 실행되기 때문에 보안 리스크가 증가 합니다. 그래서 그 대신, Jenkins가 호스트의 Docker를 제어할 수 있는 방법을 사용할 것입니다. 따라서, GCP 인스턴스 소켓을 Jenkins 컨테이너 안에 마운트 하여 Docker-out-Docker 방법을 사용하도록 하겠습니다.\r\n\r\n### Docker 설치\r\n도커 컨테이너를 만들기 위해서는 GCP 인스턴스에 Docker를 설치해야합니다. 아래 방법으로 Docker를 설치할 수 있습니다.\r\n\r\n**패키지 업데이트**<br>\r\n아래 명령어로 Docker의 GPG 키를 추가하고 Docker 패키지를 설치하는 데 필요한 환경을 설정합니다.\r\n```bash\r\n$ sudo apt-get update\r\n$ sudo apt-get install \\\r\n    ca-certificates \\\r\n    curl \\\r\n    gnupg \\\r\n    lsb-release\r\n```\r\n\r\n**Docker의 공식 GPG 키 추가**<br>\r\n```bash\r\n$ sudo mkdir -p /etc/apt/keyrings\r\n$ curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo gpg --dearmor -o /etc/apt/keyrings/docker.gpg\r\n```\r\n\r\n**Docker 저장소 설정**<br>\r\n```bash\r\n$ echo \\\r\n  \"deb [arch=$(dpkg --print-architecture) signed-by=/etc/apt/keyrings/docker.gpg] https://download.docker.com/linux/ubuntu \\\r\n  $(lsb_release -cs) stable\" | sudo tee /etc/apt/sources.list.d/docker.list > /dev/null\r\n```\r\n\r\n**Docker 엔진 설치**<br>\r\n```bash\r\n$ sudo apt-get update\r\n$ sudo apt-get install docker-ce docker-ce-cli containerd.io docker-compose-plugin\r\n```\r\n\r\n**Docker 버전 확인**<br>\r\nDocker가 정상적으로 설치되었는지 버전을 확인합니다.\r\n```bash\r\n$ docker --version​\r\n```\r\n\r\n### Jenkins 컨테이너 실행하기\r\n\r\n**Jenkins 이미지 다운로드**<br>\r\n아래 명령어로 Jenkins 이미지를 다운 받습니다.\r\n```bash\r\n$ docker pull jenkins/jenkins:lts\r\n```\r\n\r\n**Docker 소켓 마운트 하여 Jenkins 컨테이너 실행**<br>\r\nJenkins가 GCP 인스턴스의 Docker를 사용할 수 있도록 Docker 소켓을 마운트하여 Jenkins 컨테이너를 실행합니다.\r\n```bash\r\n$ docker run -d \\\r\n  --name my-jenkins \\\r\n  -p 8080:8080 \\\r\n  -v jenkins_home:/var/jenkins_home \\  # Jenkins 데이터 저장을 위한 볼륨\r\n  -v /var/run/docker.sock:/var/run/docker.sock \\  # Docker 소켓 마운트\r\n  jenkins/jenkins:lts  # Jenkins 이미지 사용\r\n```\r\n\r\n## 끝으로\r\n이렇게 Google Cloud Platform 인스턴스에 Jenkins 컨테이너 실행을 성공시켰습니다. 다음 포스팅에서는 Jenkins를 세팅하고, 파이프라인을 구성해보도록 하겠습니다."}]}},"pageContext":{}},"staticQueryHashes":[],"slicesMap":{}}