{"componentChunkName":"component---src-pages-search-jsx","path":"/search/","result":{"data":{"allMarkdownRemark":{"nodes":[{"excerpt":"안녕하세요! 이번 글에서는 자바에서 데이터를 안전하게 보호하는 방법에 대해 정리해보려고 합니다. 저는 그동안 별 생각 없이 과  를 사용하기도 했고, 에 대한 말도 많이 들어봤지만 이것들에 대해서 깊이 생각해본 적은 없었는데요. 아마 저와 같으신 분들은 이번 글이 큰 도움이 될 것 같습니다. 접근제어자는 왜 사용해야 할까? ,  이름 그대로 봤을 때 무언…","fields":{"slug":"/access_modifier/"},"frontmatter":{"date":"October 19, 2024","title":"자바에서 데이터를 안전하게 보호하는 방법 - 접근제어자, 캡슐화","tags":["접근제어자","캡슐화","JAVA"]},"rawMarkdownBody":"안녕하세요! 이번 글에서는 자바에서 데이터를 안전하게 보호하는 방법에 대해 정리해보려고 합니다.\r\n\r\n저는 그동안 별 생각 없이 `public`과 `private` `접근제어자`를 사용하기도 했고, `캡슐화`에 대한 말도 많이 들어봤지만 이것들에 대해서 깊이 생각해본 적은 없었는데요. 아마 저와 같으신 분들은 이번 글이 큰 도움이 될 것 같습니다.\r\n\r\n## 접근제어자는 왜 사용해야 할까?\r\n\r\n`private`, `public` 이름 그대로 봤을 때 무언가 비공개, 공개한다는 건 알겠는데, 언제 어떻게 왜 사용하는 걸까요?\r\n\r\n### 의도하지 않은대로 객체를 사용하는 사용자\r\n\r\n스피커 객체가 있다고 해봅시다.\r\n\r\n사용자가 스피커 객체를 사용할 때, 우리는 다음과 같이 객체가 작동하길 원합니다.\r\n\r\n1. 생성자로 초기 음량 값을 지정할 수 있다.\r\n2. 음량을 한번에 10씩 증가할 수 있다.\r\n3. 음량이 100을 넘게되면 더 이상 음량을 증가하지 않는다.\r\n\r\n\r\n```java\r\npackage access;\r\n\r\npublic class Speaker {\r\n    int volume;\r\n\r\n    Speaker(int volume) {\r\n        this.volume = volume;\r\n    }\r\n\r\n    void volumeUp() {\r\n        if (volume >= 100) {\r\n        System.out.println(\"음량을 증가할 수 없습니다. 최대 음량입니다.\");\r\n        } else {\r\n            volume += 10;\r\n            System.out.println(\"음량을 10 증가합니다.\");\r\n        }\r\n    }\r\n\r\n    void volumeDown() {\r\n        volume -= 10;\r\n        System.out.println(\"volumeDown 호출\");\r\n    }\r\n\r\n    void showVolume() {\r\n        System.out.println(\"현재 음량:\" + volume);}\r\n    }\r\n```\r\n하지만 사용자는 우리가 의도한대로 객체를 사용할까요? 이렇게 행동한다면 어떻게 될까요?\r\n\r\n```java\r\npackage access;\r\n\r\npublic class SpeakerMain {\r\n public static void main(String[] args) {\r\n     Speaker speaker = new Speaker(90);\r\n     speaker.showVolume();\r\n     speaker.volumeUp();\r\n     speaker.showVolume();\r\n     speaker.volumeUp();\r\n     speaker.showVolume();\r\n\r\n     //필드에 직접 접근\r\n     System.out.println(\"volume 필드 직접 접근 수정\");\r\n     speaker.volume = 200;\r\n     speaker.showVolume();\r\n     }\r\n}\r\n\r\n```\r\n**실행 결과**\r\n```\r\n현재 음량: 90\r\n음량을 10 증가합니다.\r\n현재 음량: 100\r\n음량을 증가할 수 없습니다. 최대 음량입니다.\r\n현재 음량: 100\r\nvolume 필드 직접 접근 수정\r\n현재 음량: 200\r\n```\r\n우리는 음량이 100을 넘게되면 더 이상 음량을 증가하지 않길 원했지만, 사용자는 `volume 필드`에 직접 접근해 음량을 200이 되도록 설정해버렸습니다.\r\n\r\n### 데이터 보호하기\r\n\r\n이런 문제를 근본적으로 해결하기 위해서는 외부에서 데이터에 접근하지 못하도록 보호해야 합니다.\r\n이럴 때 바로 **private 접근제어자**를 사용할 수 있는데요.\r\n\r\n`volume` 필드를 `private` 을 사용해서 `Speaker` 내부에 숨겨봅시다!\r\n\r\n```java\r\npackage access;\r\n\r\npublic class Speaker {\r\n    private int volume; //private 사용\r\n    ...\r\n}\r\n```\r\n**실행 결과**\r\n```java\r\n//필드에 직접 접근\r\nSystem.out.println(\"volume 필드 직접 접근 수정\");\r\nspeaker.volume = 200; //private 접근 오류\r\n```\r\n이제 사용자가 volume 필드에 접근하려고 할 때, 자바 컴파일러가 컴파일 오류를 나게 하여 직접 접근할 수 없게 되었습니다.\r\n\r\n## 캡슐화\r\n\r\n이렇게 위에서 보았듯이, 접근제어자를 적절하게 사용하지 않으면 데이터를 보호할 수 없게 되는데요.\r\n\r\n여기서 더 나아가서, `캡슐화`를 생각해볼 수 있습니다. `캡슐화`는 객체 지향 프로그래밍의 중요한 개념 중 하나인데요. 데이터와 해당 데이터를 처리하는 메서드를 하나로 묶어서 외부에서의 접근을 제한하는 것을 말합니다. 이를 통해 데이터의 직접적인 변경을 방지하거나 제한할 수도 있습니다. 쉽게 이야기해서 속성과 기능을 하나로 묶고, 외부에 꼭 필요한 기능만 노출하고 나머지는 모두 내부로 숨기게 되는 것입니다.\r\n\r\n그렇다면 어떤 것을 숨기고 어떤 것을 노출해야 할까요?\r\n\r\n### 데이터를 숨겨라\r\n\r\n아까 보았듯이, 객체 밖에서 객체 내부의 데이터를 함부로 접근하게 두면, 클래스 안에서 데이터를 다루는 모든 로직을 무시하고 데이터를 변경할 수 있습니다. 결국 모든 안전망을 다 빠져나가게 됩니다. 이것이 바로 **`캡슐화`가 깨지게 되는 것입니다.**\r\n\r\n예를 들어, 우리가 자동차를 운전할 때 자동차 부품을 다 열어서 그 안에 있는 속도계를 직접 조절하지 않습니다. 단지 자동차 제공하는 엑셀 기능을 사용해서 액셀을 밟으면, 나머지는 자동차가 다 알아서 합니다.\r\n\r\n따라서 `캡슐화`가 깨지지 않게 하려면, 데이터는 다 `private`으로 막고 객체가 제공하는 기능인 메서드를 통해서 접근해야 한다.\r\n\r\n### 기능을 숨겨라\r\n\r\n자동차를 운전하기 위해 자동차가 제공하는 복잡한 엔진 조절 기능, 배기 기능까지 우리가 알 필요는 없습니다. 우리는 단지 엑셀과 핸들 정도의 기능만 알면 됩니다.\r\n사용자에게 이런 기능까지 모두 알려준다면, 사용자가 자동차에 대해 너무 많은 것을 알아야 하는 것입니다.\r\n\r\n따라서, 사용자 입장에서 꼭 필요한 기능만 외부에 노출하는 것이 좋습니다. 나머지 기능은 모두 내부로 숨기도록 합시다.\r\n\r\n우리는 다른 개발자와 같은 코드로 개발해야할 때가 많습니다. 개발자는 열려 있는 `메소드`와 `필드`는 사용해도 된다고 이해할 수도 있고, 혹은 그걸 사용해야 된다고 이해할 수도 있습니다.\r\n\r\n그래서 결국 `접근 제어자`와 `캡슐화`를 통해 데이터를 안전하게 보호하는 것은 물론이고, 특정 `클래스`를 사용하는 개발자 입장에서 기능을 사용하는 복잡도도 낮출 수 있습니다.\r\n\r\n## 마치며\r\n\r\n그동안 `접근 제어자`와 `캡슐화`에 대해 궁금하셨던 분들에게 이 글이 도움이 되었으면 좋겠습니다. 읽어주셔서 감사드리고, 잘못된 부분이 있으면 댓글 남겨주세요.\r\n\r\nreference : https://www.inflearn.com/course/%EA%B9%80%EC%98%81%ED%95%9C%EC%9D%98-%EC%8B%A4%EC%A0%84-%EC%9E%90%EB%B0%94-%EA%B8%B0%EB%B3%B8%ED%8E%B8/dashboard"},{"excerpt":"이번에 static을 사용해 프로그램을 개발한 후 테스트를 진행했는데, 예상치 못한 결과가 나왔습니다. 이유를 살펴보니 이전에 사용한 데이터가 그대로 남아있었기 때문이었습니다. 이번 글에서는 static 변수의 동작 원리와 이러한 문제가 발생하는 이유, 그리고 적절하게 사용하는 방법에 대해 다루어 볼게요. static 변수란?  변수는 클래스에 속하는 변…","fields":{"slug":"/jpa2/"},"frontmatter":{"date":"October 18, 2024","title":"JAVA에서의 static 변수: 이전 값이 남아있는 이유와 적절한 사용법","tags":["static","JAVA"]},"rawMarkdownBody":"이번에 static을 사용해 프로그램을 개발한 후 테스트를 진행했는데, 예상치 못한 결과가 나왔습니다. 이유를 살펴보니 이전에 사용한 데이터가 그대로 남아있었기 때문이었습니다.\r\n\r\n이번 글에서는 static 변수의 동작 원리와 이러한 문제가 발생하는 이유, 그리고 적절하게 사용하는 방법에 대해 다루어 볼게요.\r\n\r\n## static 변수란?\r\n\r\n`static` 변수는 클래스에 속하는 변수로, 인스턴스마다 별도로 존재하는 것이 아니라 클래스 자체에 종속된 변수입니다. 즉, 하나의 클래스로부터 생성된 모든 객체가 동일한 `static` 변수를 공유하게 되는 것입니다.\r\n\r\n``` java\r\npublic class Counter {\r\n    public static int count = 0;\r\n    \r\n    public Counter() {\r\n        count++;\r\n    }\r\n}\r\n```\r\n위 코드에서 Counter 클래스의 count 변수는 static으로 선언되었기 때문에, 이 클래스로 생성된 모든 인스턴스는 같은 count 변수를 참조하게 됩니다. 여러 객체가 같은 값을 공유해야 할 때 static 변수를 사용하면 유용할 수 있습니다.\r\n\r\n## 이전에 사용한 값이 남아있는 이유\r\n\r\n`static` 변수가 공유된다는 특성 때문에, 이전에 저장된 값이 남아있는 경우가 발생할 수 있습니다. 이는 `static` 변수의 수명이 클래스의 수명과 동일하기 때문입니다. 프로그램이 종료되거나 클래스가 언로드되지 않는 한, `static` 변수는 계속 메모리에 남아 이전 값을 유지합니다.\r\n\r\n예를 들어, 아래 코드를 보면:\r\n\r\n``` java\r\npublic class Example {\r\n    public static int value = 0;\r\n    \r\n    public void setValue(int newValue) {\r\n        value = newValue;\r\n    }\r\n}\r\n```\r\n``` java\r\npublic class Main {\r\n    public static void main(String[] args) {\r\n        Example example1 = new Example();\r\n        example1.setValue(10);\r\n        \r\n        Example example2 = new Example();\r\n        System.out.println(example2.value); // 10 출력\r\n    }\r\n}\r\n```\r\nexample1에서 value 값을 10으로 설정했지만, example2 역시 같은 value를 공유하기 때문에 example2.value 또한 10을 출력합니다. 이처럼 클래스가 공유하는 변수이므로, 객체 간에 값이 남아있는 문제가 발생하는 것입니다.\r\n\r\n## static 변수를 적절하게 사용하는 방법\r\n\r\n이러한 특성을 이해하고 나면, static 변수를 언제, 어떻게 사용하는 것이 적절한지 고민해봐야 합니다. 몇 가지 추천 방법을 소개해보겠습니다.\r\n\r\n### 객체 간 데이터를 공유해야 할 때만 사용하자\r\n\r\n`static` 변수는 클래스 레벨에서 값을 공유해야 할 때 유용합니다. 예를 들어, 전체 프로그램에서 공통으로 사용하는 설정 값이나 객체가 몇 번 생성되었는지 추적할 때 적합합니다.\r\n\r\n``` java\r\npublic class Config {\r\n    public static String appName = \"MyApp\";\r\n}\r\n```\r\n### 상수 값으로 활용하자\r\n\r\n변경되지 않는 값, 즉 상수를 정의할 때 static과 final을 함께 사용하여 클래스 전체에서 공유할 수 있습니다.\r\n\r\n``` java\r\npublic class MathConstants {\r\n    public static final double PI = 3.14159;\r\n}\r\n```\r\n이 경우, 상수는 프로그램 어디서나 사용할 수 있지만, 값이 변경되지 않기 때문에 안전합니다.\r\n\r\n### 상태를 저장하지 않는 경우에만 사용하자\r\n\r\nstatic 변수에 프로그램의 상태나 데이터를 저장하는 것은 피하는 것이 좋습니다. 앞서 본 것처럼, 모든 인스턴스가 같은 데이터를 공유하게 되어, 예상치 못한 문제가 발생할 수 있습니다. 대신, 상태가 개별적이어야 하는 경우에는 인스턴스 변수를 사용해야 합니다.\r\n\r\n### 메모리 관리\r\n\r\nstatic 변수는 클래스가 메모리에서 언로드될 때까지 메모리에 남아 있기 때문에 메모리 사용량에 주의해야 합니다. 대규모 데이터를 static으로 저장하면 메모리 누수가 발생할 가능성이 있습니다.\r\n\r\n## static을 잘못 사용했을 때의 문제점\r\n\r\n**의도치 않은 데이터 공유:** 모든 객체가 같은 데이터를 참조하기 때문에, 한 객체에서 값을 수정하면 다른 객체에도 영향을 미칩니다.\r\n\r\n**메모리 누수:** static 변수는 클래스가 로드되는 동안 메모리에 유지되므로, 불필요하게 많은 데이터를 static으로 선언하면 메모리 누수가 발생할 수 있습니다.\r\n\r\n**테스트 어려움:** static 변수는 상태를 공유하기 때문에, 테스트 중에 상태가 공유되어 테스트가 독립적으로 수행되지 않을 수 있습니다.\r\n\r\n## 적절한 대안\r\n\r\n만약 static 변수를 통해 데이터를 공유하는 것이 아니라 독립적인 객체마다 상태를 관리하고 싶다면, 인스턴스 변수를 사용하는 것이 더 적합합니다. 예를 들어, 다음과 같이 작성할 수 있습니다.\r\n\r\n``` java\r\npublic class Example {\r\n    private int value;\r\n    \r\n    public Example(int value) {\r\n        this.value = value;\r\n    }\r\n    \r\n    public int getValue() {\r\n        return value;\r\n    }\r\n}\r\n\r\n```\r\n\r\n이렇게 하면 객체마다 고유한 value를 가지게 되므로, 객체 간에 상태가 공유되지 않습니다.\r\n\r\n## 마치며\r\n\r\nstatic 변수는 적절하게 사용하면 매우 유용하지만, 잘못 사용하면 이전 값이 남아있거나 데이터가 공유되는 예기치 못한 문제를 일으킬 수 있습니다. 이를 방지하기 위해, static 변수를 사용할 때는 해당 값이 모든 객체에서 동일하게 공유될 필요가 있는지 신중하게 검토해야 합니다. 또한, 객체별로 상태를 따로 관리해야 하는 경우에는 static 변수를 사용하지 않는 것이 좋습니다.\r\n\r\nstatic 변수는 매우 강력한 도구이지만, 그만큼 주의 깊은 사용이 필요합니다. 이를 올바르게 사용함으로써 코드의 안정성과 유지보수성을 높일 수 있습니다.\r\n\r\n읽어주셔서 감사드리고, 잘못된 부분이 있으면 댓글 남겨주세요.\r\n\r\nreference : https://www.inflearn.com/course/%EA%B9%80%EC%98%81%ED%95%9C%EC%9D%98-%EC%8B%A4%EC%A0%84-%EC%9E%90%EB%B0%94-%EA%B8%B0%EB%B3%B8%ED%8E%B8/dashboard"},{"excerpt":"JPA를 사용해 객체 간 관계를 설정하는 부분을 구현하다가 객체 변경 시 save() 메서드를 호출해야 하는지에 대한 의문이 들었습니다. 결론부터 말하자면 호출하지 않아도 됩니다. 이게 다 영속성 컨텍스트의 변경 감지(dirty checking) 특성 덕분입니다. 이번 글에서는 이러한 영속성 컨텍스트의 장점들을 알아보겠습니다. 영속성 컨텍스트란? 영속성 …","fields":{"slug":"/jpa1/"},"frontmatter":{"date":"October 04, 2024","title":"JPA에서 객체 변경 시 save() 호출이 필요할까? - 영속성 컨텍스트의 힘","tags":["JPA","Persistence context"]},"rawMarkdownBody":"JPA를 사용해 객체 간 관계를 설정하는 부분을 구현하다가 **객체 변경 시 save() 메서드를 호출해야 하는지**에 대한 의문이 들었습니다. 결론부터 말하자면 **호출하지 않아도 됩니다.**\r\n\r\n이게 다 영속성 컨텍스트의 **변경 감지(dirty checking)** 특성 덕분입니다. 이번 글에서는 이러한 영속성 컨텍스트의 장점들을 알아보겠습니다.\r\n\r\n## 영속성 컨텍스트란?\r\n영속성 컨텍스트는 엔티티를 영구적으로 저장하는 논리적인 환경입니다. 쉽게 말해, 애플리케이션과 DB 사이의 중간 계층 역할을 하죠. 엔티티 매니저(Entity Manager)가 영속성 컨텍스트를 관리하며, 이를 통해 엔티티 상태를 추적하고 관리합니다.\r\n\r\n일반적으로 EntityManager.persist() 메서드를 호출하면 객체가 DB에 저장된다고 생각할 수 있지만, 실제로는 영속성 컨텍스트에서 관리되기 시작한 것입니다. 실제 DB에 쿼리가 날아가는 시점은 트랜잭션이 커밋될 때입니다.\r\n\r\n\r\n## 영속성 컨텍스트의 주요 특성\r\n\r\n영속성 컨텍스트의 주요 특성 몇 가지를 알아보겠습니다.\r\n\r\n### 변경 감지 (Dirty Checking)\r\n앞에서 말했던 변경 감지입니다. JPA의 핵심 기능 중 하나인 변경 감지는 영속성 컨텍스트가 관리하는 엔티티의 변경사항을 자동으로 감지합니다. 트랜잭션 커밋 시점에 JPA는 영속성 컨텍스트에 있는 엔티티와 **스냅샷(최초 영속 상태의 엔티티 상태)**을 비교하여 변경된 부분이 있으면 업데이트 쿼리를 쓰기 지연 sql 저장소에 넣고, DB에 반영하고 커밋합니다. **이를 통해 객체의 변경 사항을 별도로 save() 호출 없이도 처리할 수 있습니다.**\r\n![](./image-1.png)\r\n\r\n### 1차 캐시\r\n영속성 컨텍스트는 1차 캐시를 가지고 있습니다. 엔티티를 영속화하면 DB에 바로 저장되는 것이 아니라, 먼저 1차 캐시에 저장됩니다. 이후 같은 엔티티를 조회할 때는 DB가 아닌 캐시에서 바로 조회하게 되어 성능을 높일 수 있습니다.\r\n![](./image-2.png)\r\n\r\n### 동일성 보장\r\n영속성 컨텍스트는 동일성을 보장합니다. 동일한 트랜잭션 내에서 같은 엔티티를 조회하면, == 비교로도 동일한 객체임을 확인할 수 있습니다. 즉, 동일한 엔티티는 트랜잭션 내에서 같은 인스턴스로 관리됩니다.\r\n![](./image-3.png)\r\n\r\n### 트랜잭션을 지원하는 쓰기 지연\r\n엔티티를 여러 번 저장할 때마다 DB에 쿼리가 바로 실행되지 않습니다. 영속성 컨텍스트에 저장된 SQL 쿼리들은 쓰기 지연 SQL 저장소에 모아두고, 트랜잭션 커밋 시 한꺼번에 DB로 전송됩니다. 이 덕분에 성능이 향상됩니다.\r\n![](./image-4.png)\r\n![](./image-5.png)\r\n![](./image-6.png)\r\n## 영속성 컨텍스트의 상태 DB와 동기화 하기 - 플러시(Flush)\r\n\r\n플러시(Flush)는 영속성 컨텍스트의 상태를 DB와 동기화하는 작업입니다.\r\n\r\n### 플러시가 발생할 때\r\n\r\n이때 플러시가 발생하면 다음과 같은 작업들이 이루어집니다.\r\n\r\n**1. 변경 감지 (Dirty Checking)** : 영속성 컨텍스트에 저장된 엔티티들이 변경되었는지 확인합니다.\r\n\r\n**2. 수정된 엔티티를 쓰기 지연 SQL 저장소에 등록** : 변경된 엔티티가 있으면 그에 해당하는 UPDATE 쿼리를 생성하여 쓰기 지연 SQL 저장소에 등록합니다.\r\n\r\n**3. 쓰기 지연 SQL 저장소의 쿼리를 DB에 전송** : 플러시 시점에 쓰기 지연 SQL 저장소에 저장된 등록, 수정, 삭제 쿼리들을 데이터베이스로 전송해 실제로 DB에 반영합니다.\r\n\r\n### 플러시를 발생시키는 방법\r\n\r\n**1. em.flush() 호출** : 영속성 컨텍스트를 수동으로 플러시하고 싶을 때 직접 호출할 수 있습니다.\r\n\r\n**2. 트랜잭션 커밋** : 트랜잭션이 커밋되는 시점에 JPA가 자동으로 플러시를 실행합니다. 이때 변경 사항들이 DB에 반영됩니다.\r\n\r\n**3. JPQL 쿼리 실행** : JPQL을 실행할 때도 자동으로 플러시가 호출됩니다. 이는 JPQL로 조회할 때, 영속성 컨텍스트에 있는 최신 상태의 엔티티가 반영되어야 하기 때문입니다. 예를 들어, em.persist()로 엔티티를 영속성 컨텍스트에 등록한 후, JPQL을 실행하면 DB에 반영된 상태에서 조회를 해야 하므로 플러시가 발생합니다.\r\n\r\n### 플러시의 특징\r\n\r\n**1. 영속성 컨텍스트를 비우지 않음** : 플러시는 단순히 변경 내용을 DB에 동기화할 뿐, 영속성 컨텍스트 자체를 비우지는 않습니다. 즉, 플러시 이후에도 영속성 컨텍스트는 유지됩니다.\r\n\r\n**2. 트랜잭션과의 관계** : 트랜잭션의 작업 단위가 중요하며, DB와의 동기화는 보통 커밋 직전에만 일어나면 충분합니다. 이는 트랜잭션의 일관성을 유지하기 위해 중요한 메커니즘입니다.\r\n\r\n## 그렇다면 ID로 다시 조회해야 할까?\r\n영속성 컨텍스트는 트랜잭션 내에서 동일한 엔티티의 동일성을 보장하지만, 트랜잭션 범위 밖에서는 보장되지 않기 때문에 ID로 다시 조회해야 합니다. 트랜잭션이 종료되면 영속성 컨텍스트는 더 이상 엔티티를 관리하지 않기 때문에 새로운 트랜잭션 내에서 엔티티를 조회할 필요가 있습니다.\r\n\r\n## 마치며\r\n저랑 비슷한 궁금증이 있으셨던 분들이 이 글을 통해 도움이 되셨으면 좋겠습니다. 읽어주셔서 감사드리고, 잘못된 부분이 있으면 댓글 남겨주세요.\r\n\r\nreference : https://www.inflearn.com/course/lecture?courseSlug=ORM-JPA-Basic"},{"excerpt":"이 글은 구름톤 유니브에서 들은 강의를 정리한 내용입니다. 이미지를 업로드하고, opencv를 사용하여 이미지에서 얼굴을 탐지하는 웹 서비스를 만들어보겠습니다. 이미지 DB에 저장하기 이미지 업로드 기능을 처리할 수 있는 모델을 정의한 코드입니다. 이 모델은 사용자가 업로드한 이미지 파일과 그에 대한 메타데이터(설명, 업로드된 시간)를 관리합니다. Dja…","fields":{"slug":"/groomthon_study/"},"frontmatter":{"date":"October 03, 2024","title":"예측모델 기반 face detection 웹서비스 구현","tags":["opencv","django"]},"rawMarkdownBody":"이 글은 구름톤 유니브에서 들은 강의를 정리한 내용입니다. 이미지를 업로드하고, opencv를 사용하여 이미지에서 얼굴을 탐지하는 웹 서비스를 만들어보겠습니다.\r\n\r\n## 이미지 DB에 저장하기\r\n이미지 업로드 기능을 처리할 수 있는 모델을 정의한 코드입니다. 이 모델은 사용자가 업로드한 이미지 파일과 그에 대한 메타데이터(설명, 업로드된 시간)를 관리합니다. Django의 ORM을 통해 데이터베이스에 매핑되며, 이를 사용해 이미지와 관련된 데이터를 저장하고 관리할 수 있습니다. 코드의 각 부분을 자세히 설명해보겠습니다.\r\n```python\r\nclass ImageUploadModel(models.Model):\r\n    description = models.CharField(max_length=255, blank=True)\r\n    document = models.ImageField(upload_to='images/%Y/%m/%d')\r\n    uploaded_at = models.DateTimeField(auto_now_add=True)\r\n\r\n```\r\n### description 필드\r\n이 필드는 업로드된 이미지에 대한 설명을 저장하는 텍스트 필드입니다. 이 필드의 최대 길이는 255자로 제한합니다. 폼에서 이 필드를 빈 채로 제출하는 것을 허용하여 사용자가 설명을 생략해도 오류가 발생하지 않으며, is_valid() 함수에서 유효한 데이터로 간주됩니다.\r\n\r\n### document 필드\r\n실제 이미지 파일을 저장하는 필드입니다. Django의 이미지 전용 필드로, 이미지 업로드를 다룰 때 사용합니다. 파일이 저장될 경로를 지정합니다. 여기서 %Y, %m, %d는 각각 업로드 시점의 연도, 월, 일을 나타냅니다. 예를 들어, 2024년 10월 3일에 업로드된 파일은 /images/2024/10/03/ 폴더 아래에 저장됩니다.\r\n\r\n### uploaded_at 필드\r\n파일이 업로드된 시간을 저장하는 필드입니다. 객체가 처음 생성될 때 현재 날짜와 시간이 자동으로 저장됩니다. 이후에는 수정되지 않습니다.\r\n\r\n## 폼으로 사용자에게 받은 데이터 처리하기\r\n이 코드는 Django의 폼을 정의한 것으로, 사용자로부터 데이터를 입력받아 처리하는 방식입니다. 여기서는 두 가지 폼을 다룹니다: SimpleUploadForm과 ImageUploadForm. 각각의 폼이 어떤 역할을 하는지 살펴보겠습니다.\r\n\r\n### SimpleUploadForm\r\n```python\r\nclass SimpleUploadForm(forms.Form):\r\n    title = forms.CharField(max_length=50)\r\n    image = forms.ImageField()\r\n\r\n```\r\n- **SimpleUploadForm**은 forms.Form 클래스를 상속받아 직접 정의한 폼입니다. 이 폼은 이미지를 업로드하는 가장 기본적인 기능을 구현합니다.\r\n\r\n**필드 설명**\r\n\r\n- title = forms.CharField(max_length=50): 최대 50자까지 입력 가능한 텍스트 필드입니다. 사용자가 업로드한 이미지의 제목을 입력할 수 있습니다.\r\n- image = forms.ImageField(): 이미지를 업로드할 수 있는 필드입니다. ImageField는 FileField를 상속받아, 이미지 파일인지 확인하는 추가 유효성 검사를 합니다.\r\n\r\n이 폼은 간단한 이미지 업로드와 제목 입력 기능을 제공하는데, 폼 필드가 고정되어 있어 어떤 모델에도 종속되지 않습니다. 따라서 데이터를 모델에 직접 연결하지 않는 경우에 주로 사용됩니다.\r\n\r\n### ImageUploadForm\r\n```python\r\nclass ImageUploadForm(forms.ModelForm):\r\n    class Meta:\r\n        model = ImageUploadModel\r\n        fields = ('description', 'document', )\r\n\r\n```\r\n- **ImageUploadForm**은 forms.ModelForm을 상속받아 모델과 연결된 폼을 생성합니다. 이 폼은 데이터베이스 모델인 ImageUploadModel과 직접 연결되어 있어, 사용자가 입력한 데이터가 바로 모델의 필드에 매핑됩니다.\r\n\r\n**메타 데이터**\r\n\r\n- model = ImageUploadModel: 이 폼이 연결된 모델을 명시합니다. ImageUploadModel은 업로드된 이미지와 설명을 저장하는 모델입니다.\r\n- fields = ('description', 'document', ): 사용자가 입력할 수 있는 필드 목록입니다. description과 document만을 입력받고, uploaded_at 필드는 자동으로 설정되므로 입력받지 않습니다.\r\n\r\n## 이미지에 Face detection 적용하기\r\n\r\n아래 코드를 통해 본격적으로 이미지에서 얼굴과 눈을 탐지하게 됩니다. OpenCV에서 제공하는 Haar Cascade Classifier를 사용하여 구현하게 됩니다. 코드를 자세히 알아보겠습니다.\r\n\r\n### 기본적인 이미지 처리\r\n먼저, 이미지를 받아와서 얼굴과 눈을 탐지하는 과정이 필요하겠죠? 이를 위해 이미지 파일을 cv2.imread()를 사용해 읽어옵니다. OpenCV는 이미지를 NumPy 배열 형태로 다루기 때문에, 이미지가 정상적으로 로드됐는지 확인하는 것이 중요합니다.\r\n\r\n```python\r\nimg = cv2.imread(path, 1)\r\nif type(img) is np.ndarray:\r\n    print(img.shape)\r\n\r\n```\r\n위 코드에서는 이미지를 성공적으로 로드했을 때, 그 이미지의 크기(가로, 세로, 채널)를 출력합니다. 이제 이미지가 너무 클 경우를 대비해 크기를 조정하는 과정을 추가해 보겠습니다.\r\n\r\n### 이미지 크기 조정\r\n이미지의 가로가 640px보다 크거나, 세로가 480px보다 크면 크기를 축소해줍니다. 이렇게 하면 너무 큰 이미지로 인해 처리 속도가 느려지는 것을 방지할 수 있습니다.\r\n\r\n```python\r\nresize_needed = False\r\nif img.shape[1] > 640: \r\n    resize_needed = True\r\n    new_w = img.shape[1] * (640.0 / img.shape[1])\r\n    new_h = img.shape[0] * (640.0 / img.shape[1])\r\nelif img.shape[0] > 480:\r\n    resize_needed = True\r\n    new_w = img.shape[1] * (480.0 / img.shape[0])\r\n    new_h = img.shape[0] * (480.0 / img.shape[0])\r\n\r\nif resize_needed:\r\n    img = cv2.resize(img, (int(new_w), int(new_h)))\r\n\r\n\r\n```\r\n여기서 resize_needed 플래그를 사용해 이미지 크기 조정이 필요한 경우에만 리사이즈를 진행합니다. 가로 또는 세로가 기준보다 크면, 해당 비율에 맞게 크기를 줄입니다.\r\n\r\n### 얼굴과 눈 탐지\r\n\r\n이제 본격적으로 얼굴과 눈을 탐지해볼 차례입니다. OpenCV에서 제공하는 Haar Cascade Classifier를 사용해 얼굴과 눈을 탐지할 수 있는데요, 미리 학습된 모델을 활용하여 빠르게 얼굴과 눈을 찾을 수 있습니다.\r\n\r\n```python\r\nface_cascade = cv2.CascadeClassifier(baseUrl + 'haarcascade_frontalface_default.xml')\r\neye_cascade = cv2.CascadeClassifier(baseUrl + 'haarcascade_eye.xml')\r\ngray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)\r\nfaces = face_cascade.detectMultiScale(gray, 1.3, 5)\r\n```\r\n먼저, 이미지를 그레이스케일로 변환한 후 얼굴을 탐지합니다. 여기서 detectMultiScale() 함수는 얼굴을 찾기 위한 주요 함수입니다. 탐지된 얼굴의 좌표를 바탕으로 사각형을 그려주는 작업도 같이 진행합니다.\r\n```python\r\nfor (x, y, w, h) in faces:\r\n    cv2.rectangle(img, (x, y), (x+w, y+h), (255, 0, 0), 2)\r\n    roi_gray = gray[y:y+h, x:x+w]\r\n    roi_color = img[y:y+h, x:x+w]\r\n    eyes = eye_cascade.detectMultiScale(roi_gray)\r\n    for (ex, ey, ew, eh) in eyes:\r\n        cv2.rectangle(roi_color, (ex, ey), (ex+ew, ey+eh), (0, 255, 0), 2)\r\n\r\n```\r\n얼굴을 찾은 후에는 그 영역을 기반으로 다시 눈을 탐지합니다. 얼굴 영역 내에서 눈을 찾고, 해당 부분에도 사각형을 그려줍니다. 얼굴은 파란색 사각형으로, 눈은 녹색 사각형으로 표시됩니다.\r\n\r\n### 결과 이미지 저장\r\n얼굴과 눈을 찾았으면 이제 그 결과를 이미지 파일로 저장해야겠죠? 이를 위해 cv2.imwrite() 함수를 사용해 원본 파일 경로에 덮어쓰거나, 새로운 파일을 생성해 저장할 수 있습니다.\r\n```python\r\ncv2.imwrite(path, img)\r\n\r\n```\r\n이렇게 하면 얼굴과 눈이 탐지된 이미지가 저장됩니다.\r\n\r\n## 화면 구성\r\n먼저 화면을 구성하는 코드를 알아보겠습니다. 간단히 **이미지를 간단히 업로드하는 기능, 얼굴 탐지 기능**으로 나눠져 있는데요. 아래에서 더 자세히 알아보겠습니다.\r\n### 간단한 이미지 업로드\r\n다음은 이미지를 간단히 업로드하는 기능입니다. 이 뷰는 GET 요청일 때는 빈 폼을 보여주고, POST 요청일 때는 사용자가 업로드한 이미지를 처리합니다.\r\n\r\n![](./image-1.png)\r\n\r\n```python\r\ndef simple_upload(request):\r\n  if request.method == 'POST':\r\n    form = SimpleUploadForm(request.POST, request.FILES)\r\n    if form.is_valid():\r\n        myfile = request.FILES['image']\r\n        fs = FileSystemStorage()\r\n        filename = fs.save(myfile.name, myfile)\r\n        uploaded_file_url = fs.url(filename)\r\n        context = {'form': form, 'uploaded_file_url': uploaded_file_url}\r\n        return render(request, 'opencv_webapp/simple_upload.html', context)\r\n  else:\r\n    form = SimpleUploadForm()\r\n    context = {'form': form}\r\n    return render(request, 'opencv_webapp/simple_upload.html', context)\r\n```\r\n### 얼굴 탐지 기능\r\n\r\n얼굴 탐지는 업로드한 이미지에서 얼굴을 찾아주는 기능입니다. 여기서는 사용자가 이미지를 업로드한 후, 그 이미지를 분석해 얼굴을 탐지하는 과정을 구현합니다.\r\n![](./image-2.png)\r\n\r\n```python\r\ndef detect_face(request):\r\n    if request.method == 'POST':\r\n        form = ImageUploadForm(request.POST, request.FILES)\r\n\r\n        if form.is_valid():\r\n            post = form.save(commit=False)\r\n            post.save()\r\n            imageURL = settings.MEDIA_URL + form.instance.document.name\r\n            cv_detect_face(settings.MEDIA_ROOT_URL + imageURL)\r\n            return render(request, 'opencv_webapp/detect_face.html', {'form':form, 'post':post})\r\n    else:\r\n        form = ImageUploadForm()\r\n        return render(request, 'opencv_webapp/detect_face.html', {'form':form})\r\n\r\n```\r\n- **POST 요청**: 사용자가 이미지를 업로드하고 나면 ImageUploadForm을 통해 데이터를 검증합니다. 유효한 데이터라면, 이미지 파일을 DB에 저장하고 파일 경로를 얻어온 후, 미리 만들어둔 얼굴 탐지 함수 cv_detect_face()를 호출합니다. 이 함수는 이미지에서 얼굴을 감지하고, 그 결과를 이미지에 반영하는 역할을 합니다.\r\n\r\n- **GET 요청**: 이 경우는 사용자가 처음 접근할 때 빈 폼을 보여줍니다."},{"excerpt":"지난 글에서는 Google Cloud Platform 인스턴스에 Jenkins 컨테이너를 실행시켰습니다. 이번 글에서는 Jenkins를 세팅하고, 파이프라인을 구성하여 본격적으로 프로젝트를 배포하고 CI/CD를 자동화해보겠습니다. Jenkins 세팅 Jenkins 방화벽 규칙 설정 Jenkins는 기본적으로 8080 포트를 사용하여 웹 인터페이스를 제공합…","fields":{"slug":"/deploy2/"},"frontmatter":{"date":"October 01, 2024","title":"Jenkins 사용해 CI/CD 파이프라인 자동화하기","tags":["CI/CD","Jenkins"]},"rawMarkdownBody":"지난 글에서는 Google Cloud Platform 인스턴스에 Jenkins 컨테이너를 실행시켰습니다. 이번 글에서는 Jenkins를 세팅하고, 파이프라인을 구성하여 본격적으로 프로젝트를 배포하고 CI/CD를 자동화해보겠습니다.\r\n\r\n## Jenkins 세팅\r\n\r\n### Jenkins 방화벽 규칙 설정\r\n\r\nJenkins는 기본적으로 8080 포트를 사용하여 웹 인터페이스를 제공합니다. GCP 인스턴스에서 이 포트에 접근할 수 있도록 방화벽 규칙을 설정해야 합니다.\r\n\r\nGCP 콘솔에 접속하고, 네트워크 서비스 -> VPC 네트워크 -> 방화벽 규칙으로 이동한 후, '방화벽 규칙 만들기'를 클릭하고, 다음과 같이 설정합니다.\r\n\r\n![](./image-1.png)\r\n![](./image-2.png)\r\n\r\n### Jenkins 초기 설정\r\n\r\n아래 명령어로 초기 관리자 비밀번호를 확인합니다.\r\n```bash\r\nsudo cat /var/lib/jenkins/secrets/initialAdminPassword\r\n```\r\n[GCP public ip]:8080 으로 Jenkins에 접속하여 초기 관리자 비밀번호를 입력합니다.\r\n\r\n![](./image-3.png)\r\n\r\n추천 플러그인을 설치하여 Jenkins 설정을 완료합니다.\r\n\r\n![](./image-4.png)\r\n\r\n## 파이프라인 구성하기\r\n\r\n이제 Jenkins에서 새로운 Item을 누르고, 파이프라인을 구성해보겠습니다. 저번 글에서 배포과정을 3단계로 나눴던 것처럼 **파이프라인도 git clone, build, docker build & run으로 구성**해보도록 하겠습니다.\r\n\r\n![](./image-5.png)\r\n```bash\r\npipeline {\r\n    agent any\r\n    stages {\r\n        stage('Github') {\r\n            steps {\r\n                git branch: 'develop', url: 'https://github.com/where-wear/where-wear-backend.git'\r\n            }\r\n        }\r\n        stage('Build') {\r\n            steps {\r\n                sh 'chmod +x gradlew'\r\n                sh \"./gradlew bootJar --debug\"\r\n            }\r\n        }\r\n        stage('Docker Build & Run') {\r\n            steps {\r\n                script {\r\n                    // Docker 이미지 이름 설정\r\n                    def imageName = \"wherewear-backend:latest\"\r\n                    \r\n                    // Docker 이미지를 빌드\r\n                    sh \"docker build -t ${imageName} .\"\r\n                    \r\n                    // 기존 컨테이너 중지하고 제거\r\n                    sh \"docker stop wherewear-backend\"\r\n                    sh \"docker rm wherewear-backend\"\r\n                    \r\n                    // Docker 컨테이너를 새로 실행\r\n                    sh \"docker run -d --name wherewear-backend -p 8081:8080 ${imageName}\"\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n```\r\n"},{"excerpt":"이번 글에서는 Docker와 Jenkins를 사용해 배포한 과정에 대해서 이야기해보려고 합니다.  Jenkins 없이 배포했다면 어땠을까? 일단 주요 배포과정을 단순하게 아래 3단계로 나누어 생각해 보겠습니다. 먼저 GCP 인스턴스에서 프로젝트 github repository를 clone 하여야 합니다. 다음으로는 프로젝트를 빌드해야 합니다. 프로젝트 빌…","fields":{"slug":"/deploy/"},"frontmatter":{"date":"September 28, 2024","title":"Google Cloud Platform에서 Jenkins 도커 컨테이너 실행하기","tags":["CI/CD","docker","Jenkins"]},"rawMarkdownBody":"이번 글에서는 Docker와 Jenkins를 사용해 배포한 과정에 대해서 이야기해보려고 합니다. \r\n\r\n## Jenkins 없이 배포했다면 어땠을까?\r\n일단 주요 배포과정을 단순하게 아래 3단계로 나누어 생각해 보겠습니다.\r\n\r\n먼저 GCP 인스턴스에서 **프로젝트 github repository를 clone** 하여야 합니다.\r\n```bash\r\ngit clone https://github.com/where-wear/where-wear-backend.git\r\n```\r\n다음으로는 **프로젝트를 빌드**해야 합니다. 프로젝트 빌드는 Gradle Wrapper로 할 수 있습니다. Gradle Wrapper를 실행하는 명령어인 gradlew에 실행 권한을 부여하고, 빌드 합니다.\r\n```bash\r\nchmod +x gradlew\r\n./gradlew bootJar --debug\r\n```\r\n그러면 Java 애플리케이션, 라이브러리 및 관련 리소스가 압축된 **JAR파일이 생성**됩니다. 이 JAR파일을 실행하여 **애플리케이션을 실행**시킵니다.\r\n```bash\r\njava -jar wherewear-0.0.1-SNAPSHOT.jar\r\n```\r\n성공적으로 배포가 완료 되었습니다. 하지만, 이후에 프로젝트 코드가 수정되고 메인 브랜치에 병합된다면, 위 과정을 또 반복해야 할겁니다. 이런 **수고스러운 과정을 없애기 위해서 Jenkins를 사용하여 CI(지속적 통합)/CD(지속적 배포) 과정을 자동화** 해보겠습니다.\r\n\r\n## Jenkins를 사용한 CI/CD 자동화\r\n이제 CI/CD 과정을 자동화 해보겠습니다. 먼저 GCP 인스턴스에 **Jenkins를 설치**해야 합니다. Jenkins는 스프링부트 애플리케이션과 격리된 환경에서 실행하기 위해서 GCP 인스턴스에 Jenkins를 직접 설치하지 않고, **Jenkins 도커 컨테이너를 만드는 방법**을 사용하겠습니다. 그러면 결국 **GCP 인스턴스에는 Jenkins 컨테이너와 애플리케이션 컨테이너 두 대가 띄워지게 됩니다.**\r\n\r\n생각해봐야 할 부분이 있습니다. Jenkins가 프로젝트를 빌드하고 애플리케이션 컨테이너를 띄우게 되는데, 그러면 Jenkins가 Docker를 사용하려면 Jenkins 안에 Docker를 설치해야 할까요? 하지만 이 방법(Docker-in-Docker)을 사용한다면 컨테이너 내에서 루트 권한으로 실행되기 때문에 보안 리스크가 증가 합니다. 그래서 그 대신, Jenkins가 호스트의 Docker를 제어할 수 있는 방법을 사용할 것입니다. 따라서, GCP 인스턴스 소켓을 Jenkins 컨테이너 안에 마운트 하여 Docker-out-Docker 방법을 사용하도록 하겠습니다.\r\n\r\n### Docker 설치\r\n도커 컨테이너를 만들기 위해서는 GCP 인스턴스에 Docker를 설치해야합니다. 아래 방법으로 Docker를 설치할 수 있습니다.\r\n\r\n**패키지 업데이트**<br>\r\n아래 명령어로 Docker의 GPG 키를 추가하고 Docker 패키지를 설치하는 데 필요한 환경을 설정합니다.\r\n```bash\r\n$ sudo apt-get update\r\n$ sudo apt-get install \\\r\n    ca-certificates \\\r\n    curl \\\r\n    gnupg \\\r\n    lsb-release\r\n```\r\n\r\n**Docker의 공식 GPG 키 추가**<br>\r\n```bash\r\n$ sudo mkdir -p /etc/apt/keyrings\r\n$ curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo gpg --dearmor -o /etc/apt/keyrings/docker.gpg\r\n```\r\n\r\n**Docker 저장소 설정**<br>\r\n```bash\r\n$ echo \\\r\n  \"deb [arch=$(dpkg --print-architecture) signed-by=/etc/apt/keyrings/docker.gpg] https://download.docker.com/linux/ubuntu \\\r\n  $(lsb_release -cs) stable\" | sudo tee /etc/apt/sources.list.d/docker.list > /dev/null\r\n```\r\n\r\n**Docker 엔진 설치**<br>\r\n```bash\r\n$ sudo apt-get update\r\n$ sudo apt-get install docker-ce docker-ce-cli containerd.io docker-compose-plugin\r\n```\r\n\r\n**Docker 버전 확인**<br>\r\nDocker가 정상적으로 설치되었는지 버전을 확인합니다.\r\n```bash\r\n$ docker --version​\r\n```\r\n\r\n### Jenkins 컨테이너 실행하기\r\n\r\n**Jenkins 이미지 다운로드**<br>\r\n아래 명령어로 Jenkins 이미지를 다운 받습니다.\r\n```bash\r\n$ docker pull jenkins/jenkins:lts\r\n```\r\n\r\n**Docker 소켓 마운트 하여 Jenkins 컨테이너 실행**<br>\r\nJenkins가 GCP 인스턴스의 Docker를 사용할 수 있도록 Docker 소켓을 마운트하여 Jenkins 컨테이너를 실행합니다.\r\n```bash\r\n$ docker run -d \\\r\n  --name my-jenkins \\\r\n  -p 8080:8080 \\\r\n  -v jenkins_home:/var/jenkins_home \\  # Jenkins 데이터 저장을 위한 볼륨\r\n  -v /var/run/docker.sock:/var/run/docker.sock \\  # Docker 소켓 마운트\r\n  jenkins/jenkins:lts  # Jenkins 이미지 사용\r\n```\r\n\r\n## 끝으로\r\n이렇게 Google Cloud Platform 인스턴스에 Jenkins 컨테이너 실행을 성공시켰습니다. 다음 포스팅에서는 Jenkins를 세팅하고, 파이프라인을 구성해보도록 하겠습니다."}]}},"pageContext":{}},"staticQueryHashes":[],"slicesMap":{}}