{"componentChunkName":"component---src-templates-post-jsx","path":"/jpa2/","result":{"data":{"site":{"siteMetadata":{"title":"mythofsummer"}},"markdownRemark":{"id":"4ec18b4d-4557-5619-93f7-1daeed19fe69","excerpt":"클래스랑 테이블을 맵핑하려면 @Entity가 붙어야 JPA가 해당 클래스를 관리함 스펙상 클래스에 기본 생성자 필수(파라미터가 없는 public or protected 생성자)\nfinal 클래스, enum, interface, inner 클래스는 사용 불가\ndb에 저장할 필드에는 final 사용하면 안됨 jpa에서는 애플리케이션 로딩 시점에 db테이블 생…","html":"<p>클래스랑 테이블을 맵핑하려면 @Entity가 붙어야 JPA가 해당 클래스를 관리함</p>\n<p>스펙상 클래스에 기본 생성자 필수(파라미터가 없는 public or protected 생성자)\nfinal 클래스, enum, interface, inner 클래스는 사용 불가\ndb에 저장할 필드에는 final 사용하면 안됨</p>\n<p>jpa에서는 애플리케이션 로딩 시점에 db테이블 생성 기능도 줌.\n이렇게 생성된 DDL은 개발 장비에서만 사용, 운영서버에서는 사용하지 않거나 적절히 다듬은 후 사용해야 함.</p>\n<p>hibernate.hbm2ddl.auto의 value를 create로 만들면 기존 테이블을 지우고 테이블을 다시 만듦.\nvalue에는 create-drop, update, validate 등등 있음\n개발 초기 단계에는 create or update\n테스트 서버는 update or validate\n스테이징 운영 서버는 validate or none을 사용.</p>\n<p>@column에는 unique나 length, nullable도 설정해줄 수 있음</p>\n<p>@Enumerated 하면 db에는 없는 enum 타입을 맵핑할 수 있음</p>\n<p>@Temporal 자바에 날짜 시간 날짜시간 중에 어떤거 사용할지</p>\n<p>@Lob 데이터베이스에 varchar를 넘어서는 큰 콘텐츠</p>\n<p>name에 @Column에는 unique 잘 안씀 클래스 전체에 @Table(uniqueConstraints=)이런식으로 줘야됨</p>\n<p><code class=\"language-text\">@Enumerated(EnumType.STRING)</code> 이나 <code class=\"language-text\">EnumType.ORDINAL</code>로 사용할 수 있음.\nordinal은 숫자로 구분 string은 string으로 구분 ordinal은 사용하지 않는 걸 추천</p>\n<h2 id=\"기본키-매핑\" style=\"position:relative;\"><a href=\"#%EA%B8%B0%EB%B3%B8%ED%82%A4-%EB%A7%A4%ED%95%91\" aria-label=\"기본키 매핑 permalink\" class=\"heading-anchor before\"><svg xmlns=\"http://www.w3.org/2000/svg\" width=\"15\" height=\"15\" viewBox=\"0 0 24 24\"><path d=\"M6.188 8.719c.439-.439.926-.801 1.444-1.087 2.887-1.591 6.589-.745 8.445 2.069l-2.246 2.245c-.644-1.469-2.243-2.305-3.834-1.949-.599.134-1.168.433-1.633.898l-4.304 4.306c-1.307 1.307-1.307 3.433 0 4.74 1.307 1.307 3.433 1.307 4.74 0l1.327-1.327c1.207.479 2.501.67 3.779.575l-2.929 2.929c-2.511 2.511-6.582 2.511-9.093 0s-2.511-6.582 0-9.093l4.304-4.306zm6.836-6.836l-2.929 2.929c1.277-.096 2.572.096 3.779.574l1.326-1.326c1.307-1.307 3.433-1.307 4.74 0 1.307 1.307 1.307 3.433 0 4.74l-4.305 4.305c-1.311 1.311-3.44 1.3-4.74 0-.303-.303-.564-.68-.727-1.051l-2.246 2.245c.236.358.481.667.796.982.812.812 1.846 1.417 3.036 1.704 1.542.371 3.194.166 4.613-.617.518-.286 1.005-.648 1.444-1.087l4.304-4.305c2.512-2.511 2.512-6.582.001-9.093-2.511-2.51-6.581-2.51-9.092 0z\"/></svg></a>기본키 매핑</h2>\n<p>직접 할당: @Id, 값 자동 할당: <code class=\"language-text\">@GeneratedValue(strategy=GenerationType.AUTO)</code>로 auto는 db 방언에 따라 자동으로, identity는 데이터베이스에 위임,\nsequence는 sequence 오브젝트를 만들어서 값을 generate</p>\n<p>identity의 전략은 id에 값을 넣으면 안되고 db에 insert를 해줘야 됨, null로 insert 쿼리 날아오면 그 때 db에서 값 세팅해줌</p>\n<p>id값을 알 수 있는 시점은 db에 들어가봐야 함.</p>\n<p>영속성 컨텍스트에서 관리되려면 무조건 pk값이 있어야 함. 근데 pk 값은 db에 들어가봐야지 알 수 있음.</p>\n<p>영속 상태가 되었다는 건 1차캐시에 id값이 pk값임. db에 넣기 전까지 pk값을 모름\njpa는 그래서 1차캐시에 넣을 수 있는 방법이 없음. 그래서 identity 전략에서만 em.persist 호출한 시점에 바로 insert 쿼리 날려버림.(커밋하면 날려버리는게 아님) 그리고 db에서 id 읽어와서 영속성컨텍스트를 사용함.</p>","frontmatter":{"title":"JPA mapping","date":"October 10, 2024","update":"October 10, 2024","tags":["JPA"],"series":null},"fields":{"slug":"/jpa2/","readingTime":{"minutes":3.13}}},"seriesList":{"edges":[{"node":{"id":"926b5e59-e6c2-5645-8db2-7def69c806e4","fields":{"slug":"/jpa1/"},"frontmatter":{"title":"JPA에서 객체 변경 시 save() 호출이 필요할까? - 영속성 컨텍스트의 힘"}}},{"node":{"id":"4ec18b4d-4557-5619-93f7-1daeed19fe69","fields":{"slug":"/jpa2/"},"frontmatter":{"title":"JPA mapping"}}},{"node":{"id":"74d7f977-0c43-5125-9015-fd329e897958","fields":{"slug":"/about/"},"frontmatter":{"title":"This is about page ✋"}}}]},"previous":{"fields":{"slug":"/jpa1/"},"frontmatter":{"title":"JPA에서 객체 변경 시 save() 호출이 필요할까? - 영속성 컨텍스트의 힘"}},"next":null},"pageContext":{"id":"4ec18b4d-4557-5619-93f7-1daeed19fe69","series":null,"previousPostId":"926b5e59-e6c2-5645-8db2-7def69c806e4","nextPostId":null}},"staticQueryHashes":[],"slicesMap":{}}